**Collections Framework**, a cornerstone of Java programming used for storing, manipulating, and processing groups of data.

---

### **What is the Collections Framework?**

The **Java Collections Framework (JCF)** is a set of classes and interfaces in `java.util` that provide data structures like lists, sets, maps, and queues. It allows developers to handle collections of objects easily with reusable and efficient algorithms.

---

### **Key Interfaces in the Framework**

1. **List** (Ordered Collection):

   - Allows duplicate elements.
   - Preserves insertion order.
   - Common Implementations:
     - **ArrayList:** Dynamic arrays.
     - **LinkedList:** Doubly-linked list structure.
   - Example:
     ```java
     List<String> names = new ArrayList<>();
     names.add("Alice");
     names.add("Bob");
     System.out.println(names);  // Output: [Alice, Bob]
     ```
2. **Set** (Unique Elements):

   - Does not allow duplicate elements.
   - Common Implementations:
     - **HashSet:** Unordered collection.
     - **LinkedHashSet:** Maintains insertion order.
     - **TreeSet:** Sorted collection.
   - Example:
     ```java
     Set<Integer> numbers = new HashSet<>();
     numbers.add(5);
     numbers.add(5);  // Duplicate, ignored
     System.out.println(numbers);  // Output: [5]
     ```
3. **Map** (Key-Value Pairs):

   - Stores data as key-value pairs.
   - Keys must be unique.
   - Common Implementations:
     - **HashMap:** Unordered collection.
     - **LinkedHashMap:** Maintains insertion order.
     - **TreeMap:** Sorted by keys.
   - Example:
     ```java
     Map<String, Integer> ageMap = new HashMap<>();
     ageMap.put("Alice", 30);
     ageMap.put("Bob", 25);
     System.out.println(ageMap);  // Output: {Alice=30, Bob=25}
     ```
4. **Queue** (FIFO - First In, First Out):

   - Useful for processing data in order.
   - Common Implementations:
     - **PriorityQueue:** Elements ordered based on priority.
     - **LinkedList:** Can function as a queue.
   - Example:
     ```java
     Queue<String> tasks = new LinkedList<>();
     tasks.add("Task1");
     tasks.add("Task2");
     System.out.println(tasks.poll());  // Output: Task1
     ```

---

### **Utility Classes**

Java provides utility classes like **Collections** and **Arrays** to perform operations on collections:

- **Sorting:**
  ```java
  Collections.sort(list);
  ```
- **Searching:**
  ```java
  int index = Collections.binarySearch(list, element);
  ```

---

### **Interview-Style Questions and Answers**

1. **Q:** What are the key differences between a List and a Set?**A:** A **List** allows duplicate elements and preserves insertion order, while a **Set** does not allow duplicates and may not maintain order (e.g., HashSet).
2. **Q:** How does a HashMap work internally?**A:** A **HashMap** uses a hashing algorithm to store key-value pairs in buckets. Keys are hashed into a hashcode, and collisions are resolved using linked lists or balanced trees in modern implementations.
3. **Q:** Why would you use a TreeMap over a HashMap?**A:** A **TreeMap** maintains a sorted order of keys, making it useful when you need natural ordering. A **HashMap** is faster for general-purpose lookups but doesn’t guarantee order.
4. **Q:** What’s the difference between ArrayList and LinkedList?**A:**

   - **ArrayList:** Backed by a dynamic array; better for random access.
   - **LinkedList:** Uses a doubly-linked list; better for frequent inserts and deletes.
5. **Q:** What is the purpose of the Collections utility class?
   **A:** It provides static methods for operations like sorting, searching, and reversing a collection.

---

The Collections Framework is an essential toolkit for handling and manipulating data in Java.

**ArrayList**, one of the most commonly used classes in the **Collections Framework**. We'll cover **what it is**, **how it works**, **examples**, and **interview-focused Q&A**.

---

### **ArrayList Overview**

- **What is it?**ArrayList is a **resizable array** implementation in Java, part of the `java.util` package. Unlike arrays, it grows and shrinks dynamically as elements are added or removed.
- **Features:**

  1. Allows duplicate elements.
  2. Preserves insertion order.
  3. Provides random access (via index) in **O(1)** time.
  4. Not synchronized (thread-unsafe), but you can make it thread-safe using `Collections.synchronizedList()`.
- **When to Use:**
  Use ArrayList when you need a **dynamic array** with fast lookups and occasional modifications.

---

### **How ArrayList Works**

1. Internally, ArrayList uses a **dynamic array**.
2. When elements are added and exceed the current capacity, the internal array is **resized (grown by 50%)**.
3. **Indexing:** Elements are stored in contiguous memory, so accessing an element by its index is constant time (`O(1)`).
4. Adding/removing elements may involve **shifting** other elements, which takes time proportional to the number of elements (`O(n)` in the worst case).

---

### **Basic Operations**

Here’s a breakdown of common operations with examples:

#### **1. Adding Elements**

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Alice");
        list.add("Bob");
        System.out.println(list);  // Output: [Alice, Bob]
    }
}
```

#### **2. Accessing Elements**

```java
System.out.println(list.get(0));  // Output: Alice
```

#### **3. Modifying Elements**

```java
list.set(1, "Charlie");  // Replace "Bob" with "Charlie"
System.out.println(list);  // Output: [Alice, Charlie]
```

#### **4. Removing Elements**

```java
list.remove("Alice");  // Removes Alice
System.out.println(list);  // Output: [Charlie]
```

#### **5. Iterating Over Elements**

Using an enhanced for-loop:

```java
for (String name : list) {
    System.out.println(name);
}
```

---

### **Advantages and Disadvantages**

| **Advantages**      | **Disadvantages**                  |
| ------------------------- | ---------------------------------------- |
| Dynamic resizing          | Slower for frequent insertions/deletions |
| Fast random access (O(1)) | Not synchronized (thread-unsafe)         |
| Easy to use and flexible  | Uses more memory than simple arrays      |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** What’s the difference between an Array and an ArrayList?**A:**

   - **Array:** Fixed size, can store primitives or objects.
   - **ArrayList:** Resizable, can only store objects (autoboxing allows primitives).

   Example:

   ```java
   int[] array = {1, 2, 3};  // Fixed size
   ArrayList<Integer> list = new ArrayList<>();  // Dynamic size
   ```
2. **Q:** How does ArrayList handle resizing?
   **A:** When its capacity is exceeded, ArrayList creates a new array with **50% larger capacity**, copies existing elements to it, and replaces the old array.

---

#### **Performance**

3. **Q:** What is the time complexity for adding an element?**A:**

   - **Amortized O(1):** When adding at the end and no resizing is needed.
   - **O(n):** If resizing or shifting elements is required (e.g., inserting at the beginning).
4. **Q:** Is ArrayList thread-safe?
   **A:** No, ArrayList is not synchronized. To make it thread-safe, use:

   ```java
   List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
   ```

---

#### **Advanced**

5. **Q:** How can you improve performance if an ArrayList’s size is known beforehand?**A:** Use the `ensureCapacity()` method to allocate the required memory in advance, reducing resizing overhead.

   ```java
   ArrayList<Integer> list = new ArrayList<>();
   list.ensureCapacity(100);  // Optimize for 100 elements
   ```
6. **Q:** Why is random access faster in ArrayList compared to LinkedList?
   **A:** ArrayList stores elements in contiguous memory, allowing instant access via index (`O(1)`). LinkedList requires traversal (`O(n)`) as elements are scattered and linked.

---

**LinkedList**. advantages and disadvantages, examples, and interview questions to deepen your understanding.

---

### **LinkedList Overview**

- **What is it?**LinkedList is a doubly-linked list implementation in Java, part of the `java.util` package. Unlike ArrayList, it uses nodes for storing data, where each node contains:

  - **Data:** The actual element.
  - **Next Pointer:** Points to the next node.
  - **Previous Pointer:** Points to the previous node.
- **Features:**

  1. Allows duplicate elements.
  2. Maintains insertion order.
  3. Efficient for frequent additions and deletions (O(1) for insertion/removal at the ends).
  4. Slower for random access compared to ArrayList (`O(n)`).
- **When to Use:**
  Use LinkedList when your program involves **frequent insertions or deletions**, and random access isn’t critical.

---

### **How LinkedList Works**

1. Each element (node) is stored separately in memory.
2. Nodes contain pointers to the next and previous nodes, forming a chain.
3. Traversing the list involves following these pointers sequentially (`O(n)`).

---

### **Basic Operations**

Here’s a breakdown of common operations with examples:

#### **1. Adding Elements**

```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("Alice");
        list.add("Bob");
        System.out.println(list);  // Output: [Alice, Bob]
    }
}
```

#### **2. Accessing Elements**

```java
System.out.println(list.get(0));  // Output: Alice
```

#### **3. Adding Elements at Specific Positions**

```java
list.addFirst("Charlie");  // Adds at the beginning
list.addLast("Dave");      // Adds at the end
System.out.println(list);  // Output: [Charlie, Alice, Bob, Dave]
```

#### **4. Removing Elements**

```java
list.remove("Alice");  // Removes Alice
list.removeFirst();    // Removes the first element
list.removeLast();     // Removes the last element
System.out.println(list);
```

#### **5. Iterating Over Elements**

Using a `for-each` loop:

```java
for (String name : list) {
    System.out.println(name);
}
```

---

### **Advantages and Disadvantages**

| **Advantages**                   | **Disadvantages**                     |
| -------------------------------------- | ------------------------------------------- |
| Efficient for frequent inserts/deletes | Slower for random access than ArrayList     |
| Can function as a Queue/Deque          | Higher memory overhead due to node pointers |
| Dynamic size                           | Traversal requires `O(n)` time            |

---

### **Differences Between LinkedList and ArrayList**

| **Aspect**                    | **ArrayList**      | **LinkedList**   |
| ----------------------------------- | ------------------------ | ---------------------- |
| **Underlying Structure**      | Resizable array          | Doubly-linked list     |
| **Random Access**             | O(1) (instant)           | O(n) (sequential)      |
| **Insert/Delete Performance** | Slower (shifting needed) | Faster (no shifting)   |
| **Memory Use**                | Less memory (contiguous) | More memory (pointers) |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** How does LinkedList differ from ArrayList?**A:**

   - LinkedList uses nodes and pointers for storage, while ArrayList uses a dynamic array.
   - LinkedList is faster for insertions/deletions but slower for random access.
2. **Q:** When would you prefer LinkedList over ArrayList?
   **A:** Use LinkedList when your application involves frequent additions or deletions, especially at the beginning or middle of the list.

---

#### **Performance**

3. **Q:** What is the time complexity for accessing an element in LinkedList?**A:** `O(n)` since traversal is required to reach the desired node.
4. **Q:** What is the time complexity for inserting elements at the beginning?
   **A:** `O(1)` because LinkedList doesn’t require shifting elements like ArrayList.

---

#### **Advanced**

5. **Q:** Can LinkedList function as a Queue?**A:** Yes, LinkedList implements both `Queue` and `Deque`, making it suitable for FIFO operations.Example:

   ```java
   LinkedList<String> queue = new LinkedList<>();
   queue.add("Task1");
   queue.poll();  // Retrieves and removes the head (FIFO)
   ```
6. **Q:** What happens internally when `addFirst()` is called?
   **A:** A new node is created, and its pointers are updated to link it to the current first node. The head pointer is shifted to this new node.

---

7. **Q:** If you assign a  object to both  and  interface references, what is the difference in their behavior?
   **A:** Great question! The `LinkedList` class in Java is quite versatile because it implements both the `List` and `Queue` interfaces. This makes it adaptable, allowing to use it as either a `List` or a `Queue`, depending on the requirements.

### How it works:

The `LinkedList` class inherits behaviors from the following interfaces:

1. **List Interface:** When treated as a `List`, `LinkedList` behaves as a doubly linked list, allowing operations like random access (by index), adding elements at specific positions, etc. The `List` interface is perfect for scenarios where you need sequential access or manipulation.
2. **Queue Interface:** When treated as a `Queue`, `LinkedList` supports typical queue operations like `enqueue`, `dequeue`, and others defined in the `Queue` and `Deque` interfaces. This is great for implementing FIFO (First-In, First-Out) functionality or even a double-ended queue (Deque).

Here’s an example:

```java
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        // Using LinkedList as a List
        List<String> list = new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        System.out.println("List: " + list);

        // Using LinkedList as a Queue
        Queue<String> queue = new LinkedList<>();
        queue.add("X");
        queue.add("Y");
        queue.add("Z");
        System.out.println("Queue: " + queue);

        // Queue operations
        System.out.println("Dequeued Element: " + queue.poll());
        System.out.println("Queue after poll: " + queue);
    }
}
```

### Difference:

The difference lies in the intended use and the type of operations you can perform:

* **When used as a List:** You’ll primarily focus on methods like `add(index, element)`, `get(index)`, and `remove(index)`, which are specific to `List`. It’s more about accessing and manipulating elements based on their position.
* **When used as a Queue:** You’ll use methods such as `offer(element)`, `poll()`, and `peek()`, which are specific to `Queue`. These emphasize accessing elements based on their addition/removal order.

While `LinkedList` is highly flexible, using it exclusively for one interface (e.g., `Queue`) might be better for code clarity and intent. It’s always good to pick an implementation that clearly matches your primary use case. For example, `ArrayList` might be better for `List` needs, and `ArrayDeque` for `Queue`.

If you assign a `LinkedList` object to a `List` interface reference and then try to call queue-specific methods,  it will result in a compile-time error. Here's why:

When you assign a `LinkedList` object to a `List` interface reference, you're essentially limiting access to only the methods defined in the `List` interface. Even though the underlying object (`LinkedList`) implements `Queue` as well, the compiler only allows you to invoke methods declared in the `List` interface on this reference.

### Example:

```java
List<String> list = new LinkedList<>(); // LinkedList assigned to List reference
list.add("A"); // Works fine because 'add' is a method in List

list.offer("B"); // Compile-time error: 'offer' is not defined in List
```

### Why does this happen?

The compiler looks at the reference type (`List` in this case) to determine what methods are available. Since `offer()`, `poll()`, and other queue-specific methods are not part of the `List` interface, the compiler throws an error if you try to use them.

### How to avoid this error:

If you need to use queue-specific methods, you should assign the `LinkedList` object to a `Queue` reference:

```java
Queue<String> queue = new LinkedList<>();
queue.offer("A"); // Works fine
queue.add("B");   // Works fine because 'add' is also part of Queue
```

This separation ensures type safety and prevents accidental misuse of methods.

---

Let’s explore **HashSet**, one of the implementations of the **Set** interface in Java. It's designed for storing unique elements and is ideal for fast operations like searching, adding, and removing items.

---

### **HashSet Overview**

- **HashSet** is a collection that stores unique elements in an unordered manner. It uses a **hashing mechanism** to ensure fast operations and prevents duplicates.
- **Features:**

  1. Stores **only unique elements**.
  2. Does **not maintain insertion order**.
  3. Provides **O(1)** average time complexity for basic operations like add, remove, and contains.
  4. Allows **null** values.
- **When to Use:**
  Use HashSet when you need a collection with **unique elements** and don’t care about the order.

---

### **How HashSet Works Internally**

1. HashSet is backed by a **HashMap** internally, where:
   - Each element acts as a key in the HashMap.
   - The value is a constant (`dummy`) object.
2. The elements are hashed into hashcodes, determining their position in the HashMap.
3. **Collisions** (two elements with the same hashcode) are resolved using linked lists or balanced trees in the buckets.

---

### **Basic Operations**

Here are common operations with examples:

#### **1. Adding Elements**

```java
import java.util.HashSet;

public class Main {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();
        set.add("Alice");
        set.add("Bob");
        set.add("Alice");  // Duplicate, ignored
        System.out.println(set);  // Output: [Alice, Bob]
    }
}
```

#### **2. Removing Elements**

```java
set.remove("Alice");
System.out.println(set);  // Output: [Bob]
```

#### **3. Checking for Elements**

```java
boolean exists = set.contains("Bob");  // true
System.out.println(exists);
```

#### **4. Iterating Over Elements**

Using an enhanced for-loop:

```java
for (String name : set) {
    System.out.println(name);
}
```

---

### **Advantages and Disadvantages**

| **Advantages**           | **Disadvantages**                     |
| ------------------------------ | ------------------------------------------- |
| Fast operations (O(1) average) | Unordered collection, no control over order |
| Ensures unique elements        | Relies on hashing, may have collisions      |
| Allows null values             | Iterating order is not predictable          |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** What is a HashSet, and how does it ensure uniqueness?
   **A:** HashSet is a collection that prevents duplicate elements by using a hashing mechanism. It internally uses a HashMap where each element is stored as a key.
2. **Q:** Can HashSet contain null values?
   **A:** Yes, HashSet allows one `null` value. It is treated like any other object but doesn’t affect the hashing mechanism.

---

#### **Performance**

3. **Q:** What is the time complexity for adding an element to a HashSet?
   **A:** Average time complexity is **O(1)** due to hashing. However, in rare cases with many hash collisions, it may degrade to **O(n)**.
4. **Q:** How does HashSet handle hash collisions?
   **A:** HashSet uses buckets in the backing HashMap. Collisions are resolved using linked lists or balanced trees (depending on the Java version, i.e., Java 7 and Earlier resolves using a linked list and from Java 8 and Later uses if the number of entries in a single bucket exceeds a certain threshold (default is 8), the collision resolution switches from a linked list to a balanced binary search tree (red-black tree).balanced binary search tree (red-black tree)).
   **Key Thresholds:**
   - Bucket Threshold for Treeify: 8 entries.
   - Bucket Threshold for Untreeify: 6 entries.

**Treeify** and **Untreeify** are terms related to the internal implementation of `HashMap` in Java. These processes occur when handling collisions in the hash buckets. Let me explain:

### 1. **Treeify**:

- **What It Is:** Treeify is the process of converting a **collision chain** (a linked list in a hash bucket) into a **balanced binary search tree (red-black tree)**.
- **Why It's Done:** This happens to optimize performance when a single bucket has too many elements due to hash collisions. A linked list has a worst-case time complexity of **O(n)** for retrieval, while a red-black tree has a worst-case time complexity of **O(log n)**.
- **When It Happens:**
  - If the number of elements in a single bucket exceeds a predefined threshold (default is **8 entries**).
  - The `HashMap` must also have enough total buckets (default is **64 buckets**) before treeification occurs to avoid premature tree creation.
- **Result:** The bucket now uses a red-black tree instead of a linked list for storage.

### 2. **Untreeify**:

- **What It Is:** Untreeify is the reverse process of Treeify—converting a red-black tree in a bucket back into a linked list.
- **Why It's Done:** This happens when the number of elements in the bucket drops below a predefined threshold (default is **6 entries**) due to deletions. A linked list is more memory-efficient for smaller numbers of elements.
- **When It Happens:** If the tree structure becomes unnecessary because the size of the bucket’s collision chain reduces.

### **Thresholds for Treeify and Untreeify**:

- **Treeify Threshold:** Default is **8**.
- **Untreeify Threshold:** Default is **6**.
- These thresholds are set to balance performance and memory usage effectively.

### Example Workflow in `HashMap`:

1. Initially, all buckets use linked lists.
2. If a single bucket grows beyond 8 entries:
   - Java treeifies the bucket into a red-black tree (if total bucket size is 64 or more).
3. If that bucket later reduces below 6 entries:
   - Java untreeifies it back to a linked list to save memory.

### Key Takeaway:

These mechanisms ensure the `HashMap` remains efficient in scenarios with high or low hash collisions, striking a balance between speed and memory usage.

Because they are marked as `final` , you cannot modify them.

---

#### **Advanced**

5. **Q:** How does HashSet compare to TreeSet in terms of performance?
   **A:**
   - HashSet is faster for add/remove operations (**O(1)**).
   - TreeSet maintains elements in sorted order but has slower operations (**O(log n)**).
6. **Q:** What happens internally when you add an element to a HashSet?
   **A:** When an element is added:
   - Its hashcode is computed.
   - The element is placed in a bucket based on the hashcode.
   - If the bucket already contains elements, HashSet checks for duplicates and resolves collisions.

---

**TreeSet**, another important implementation of the **Set** interface in Java. It’s widely used when you need a collection of unique elements **sorted in natural or custom order**.

---

### **TreeSet Overview**

- **TreeSet** is a collection that implements the **NavigableSet** interface and is backed by a **TreeMap**. It sorts elements **naturally** (ascending order by default) or according to a custom **Comparator**.
- **Features:**

  1. Stores **only unique elements**.
  2. Elements are automatically sorted.
  3. Provides methods for navigating subsets (`headSet`, `tailSet`, `subSet`).
  4. Not thread-safe (can be synchronized manually).
  5. Does **not allow null values** (throws `NullPointerException`).
- **When to Use:**
  Use TreeSet when you need a **sorted collection** of unique elements and ordering is important.

---

### **How TreeSet Works Internally**

1. TreeSet is backed by a **Red-Black Tree**, a self-balancing binary search tree.
2. When an element is added, it’s placed into the tree based on its natural ordering or a custom comparator.
3. Duplicate elements are ignored, and an attempt to insert `null` will throw an exception.

---

### **Basic Operations**

Here’s a breakdown of common operations with examples:

#### **1. Adding Elements**

```java
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        TreeSet<Integer> set = new TreeSet<>();
        set.add(10);
        set.add(5);
        set.add(15);
        System.out.println(set);  // Output: [5, 10, 15] (sorted order)
    }
}
```

#### **2. Removing Elements**

```java
set.remove(10);  
System.out.println(set);  // Output: [5, 15]
```

#### **3. Navigating Elements**

- **First and Last Elements:**
  ```java
  System.out.println(set.first());  // Output: 5
  System.out.println(set.last());   // Output: 15
  ```
- **Subset Views:**
  ```java
  System.out.println(set.headSet(10));   // Output: [5]
  System.out.println(set.tailSet(10));   // Output: [10, 15]
  System.out.println(set.subSet(5, 15)); // Output: [5, 10]
  ```

#### **4. Iterating Over Elements**

```java
for (int num : set) {
    System.out.println(num);  // Prints elements in ascending order
}
```

---

### **Advantages and Disadvantages**

| **Advantages**        | **Disadvantages**                 |
| --------------------------- | --------------------------------------- |
| Maintains sorted order      | Slower performance compared to HashSet  |
| Unique elements only        | Does not allow null values              |
| Provides navigation methods | Higher memory overhead (Red-Black Tree) |

---

### **Differences Between HashSet and TreeSet**

| **Aspect**               | **HashSet**                | **TreeSet**               |
| ------------------------------ | -------------------------------- | ------------------------------- |
| **Underlying Structure** | Hashing (backed by HashMap)      | Tree structure (Red-Black Tree) |
| **Order**                | Unordered                        | Sorted                          |
| **Performance**          | O(1) for add/remove              | O(log n) for add/remove         |
| **Null Support**         | Allows null values               | Does not allow null values      |
| **Use Case**             | Fast lookups and unique elements | Sorted unique elements          |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** What is a TreeSet, and how does it differ from a HashSet?
   **A:** TreeSet is a sorted set backed by a Red-Black Tree. It ensures elements are unique and in ascending order. In contrast, HashSet is unordered and focuses on fast access.
2. **Q:** Why does TreeSet not allow null values?
   **A:** TreeSet uses comparison to sort elements, but comparing `null` values with other objects throws a `NullPointerException`.

---

#### **Performance**

3. **Q:** What is the time complexity of adding elements to a TreeSet?
   **A:** The time complexity is **O(log n)** because TreeSet is based on a Red-Black Tree.
4. **Q:** Is TreeSet thread-safe?
   **A:** No, TreeSet is not synchronized. You can make it thread-safe by wrapping it with `Collections.synchronizedSortedSet()`.
   Example:

   ```java
   SortedSet<Integer> synchronizedSet = Collections.synchronizedSortedSet(new TreeSet<>());
   ```

---

#### **Advanced**

5. **Q:** How can you customize the sorting order in TreeSet?
   **A:** Use a **Comparator** to define custom sorting logic. Pass the comparator to the TreeSet constructor.
   Example:
   ```java
   TreeSet<Integer> set = new TreeSet<>((a, b) -> b - a);  // Descending order
   set.add(10);
   set.add(5);
   set.add(15);
   System.out.println(set);  // Output: [15, 10, 5]
   ```
6. **Q:** How would you retrieve a subset of elements using TreeSet?
   **A:** Use navigation methods like `headSet()`, `tailSet()`, and `subSet()` to get specific subsets based on conditions.
   Example:
   ```java
   TreeSet<Integer> set = new TreeSet<>();
   set.add(5);
   set.add(10);
   set.add(15);
   System.out.println(set.subSet(5, 15));  // Output: [5, 10]
   ```

---

TreeSet is a powerful data structure for scenarios requiring sorted and unique elements.

Let's dive into **HashMap**, one of the most powerful and commonly used data structures in Java. It's perfect for storing and accessing data using a **key-value pair** mechanism.

---

### **HashMap Overview**

- A **HashMap** is a collection that implements the **Map** interface and stores elements as **key-value pairs**. Keys must be unique, but values can be duplicated.
- **Features:**

  1. Allows one `null` key and multiple `null` values.
  2. Does **not maintain insertion order** (keys are stored based on their hashcode).
  3. Provides **O(1)** average time complexity for operations like get and put.
  4. **Not synchronized**, meaning it is not thread-safe.
- **When to Use:**
  Use HashMap when you need fast lookups and don't require ordering of the keys or values.

---

### **How HashMap Works Internally**

1. **Hashing Mechanism:**

   - Each key is hashed into a hashcode using the `hashCode()` method.
   - This hashcode determines the bucket where the key-value pair will be stored.
2. **Collision Handling:**

   - When two keys produce the same hashcode, HashMap uses a **linked list** or a **balanced tree** (since Java 8) to store multiple pairs in the same bucket.
3. **Key Retrieval:**

   - HashMap locates the bucket using the hashcode and retrieves the correct value using the `equals()` method to compare keys.

---

### **Basic Operations**

#### **1. Adding Elements**

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        map.put("Alice", 25);  // Add a key-value pair
        map.put("Bob", 30);
        System.out.println(map);  // Output: {Alice=25, Bob=30}
    }
}
```

#### **2. Accessing Values**

```java
int age = map.get("Alice");  // Retrieve the value for key "Alice"
System.out.println(age);  // Output: 25
```

#### **3. Removing Elements**

```java
map.remove("Alice");  // Removes the key-value pair for "Alice"
System.out.println(map);  // Output: {Bob=30}
```

#### **4. Checking for Keys/Values**

```java
boolean hasKey = map.containsKey("Bob");  // true
boolean hasValue = map.containsValue(30);  // true
```

#### **5. Iterating Over Entries**

```java
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

---

### **Advantages and Disadvantages**

| **Advantages**           | **Disadvantages**                      |
| ------------------------------ | -------------------------------------------- |
| Fast operations (O(1) average) | Not synchronized (thread-unsafe)             |
| Allows null key and values     | Performance can degrade with hash collisions |
| Flexible key-value mapping     | Unpredictable ordering of keys               |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** What is a HashMap, and how does it work?
   **A:** HashMap is a key-value pair collection that uses hashing to store and retrieve elements efficiently. It maps a key to a specific bucket using the key’s hashcode and resolves collisions using linked lists or trees.
2. **Q:** Can a HashMap have duplicate keys?
   **A:** No, keys in a HashMap must be unique. If you attempt to insert a duplicate key, the new value will overwrite the existing one.

---

#### **Performance**

3. **Q:** What is the time complexity of get and put operations in HashMap?
   **A:** The average time complexity is **O(1)**. However, in the worst case (e.g., hash collisions), it can degrade to **O(n)**.
4. **Q:** How does HashMap handle collisions?
   **A:** HashMap uses **separate chaining** where collisions are resolved by storing multiple entries in a linked list or a balanced tree within the same bucket.

---

#### **Advanced**

5. **Q:** What is the difference between `hashCode()` and `equals()` in HashMap?
   **A:**
   - `hashCode()`: Determines the bucket where the key-value pair will be stored.
   - `equals()`: Ensures that keys are unique by comparing them within the same bucket.
6. **Q:** Why is HashMap not thread-safe, and how can you make it thread-safe?
   **A:** HashMap is not synchronized, meaning multiple threads can cause race conditions. To make it thread-safe, use `Collections.synchronizedMap()` or use **ConcurrentHashMap**.
   Example:
   ```java
   Map<String, Integer> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
   ```
7. **Q:** What improvements were made to HashMap in Java 8?
   **A:** Java 8 introduced **tree-based buckets**. When a bucket exceeds a certain threshold (e.g., 8 entries), the linked list in that bucket is converted into a balanced tree (Red-Black Tree) to optimize performance.

---

**TreeMap**, another important implementation of the **Map** interface in Java. TreeMap is ideal when you need to store key-value pairs in a **sorted order**.

---

### **TreeMap Overview**

- **TreeMap** is a collection in Java that implements the **NavigableMap** interface and is backed by a **Red-Black Tree**. It sorts its keys either in their natural order or based on a custom **Comparator**.
- **Features:**

  1. Stores **key-value pairs** like HashMap.
  2. Keys are **sorted** in ascending order by default.
  3. Does not allow **null keys** (throws `NullPointerException`), but allows multiple **null values**.
  4. Provides methods for navigating subsets (`headMap`, `tailMap`, `subMap`).
  5. Not synchronized (can be made thread-safe manually).
- **When to Use:**
  Use TreeMap when you need a map where the **keys are always sorted** or require range-based queries.

---

### **How TreeMap Works Internally**

1. TreeMap is implemented as a **Red-Black Tree**, a self-balancing binary search tree.
2. Keys are stored in sorted order, determined by their natural ordering (`Comparable`) or a custom **Comparator** if provided.
3. Operations like `put()`, `get()`, and `remove()` take **O(log n)** time because of the Red-Black Tree.

---

### **Basic Operations**

#### **1. Adding Key-Value Pairs**

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(3, "Three");
        map.put(1, "One");
        map.put(2, "Two");
        System.out.println(map);  // Output: {1=One, 2=Two, 3=Three} (sorted by keys)
    }
}
```

#### **2. Accessing Values**

```java
String value = map.get(2);  // Retrieves value for key 2
System.out.println(value);  // Output: Two
```

#### **3. Removing Key-Value Pairs**

```java
map.remove(1);  // Removes the entry with key 1
System.out.println(map);  // Output: {2=Two, 3=Three}
```

#### **4. Navigating the Map**

- **First and Last Keys:**
  ```java
  System.out.println(map.firstKey());  // Output: 2
  System.out.println(map.lastKey());   // Output: 3
  ```
- **Subset Views:**
  ```java
  System.out.println(map.headMap(3));   // Output: {2=Two}
  System.out.println(map.tailMap(2));   // Output: {2=Two, 3=Three}
  System.out.println(map.subMap(2, 3)); // Output: {2=Two}
  ```

#### **5. Iterating Over Entries**

```java
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

---

### **Advantages and Disadvantages**

| **Advantages**         | **Disadvantages**                 |
| ---------------------------- | --------------------------------------- |
| Maintains sorted key order   | Slower than HashMap (O(log n))          |
| Supports range-based queries | Does not allow null keys                |
| Provides navigation methods  | Higher memory overhead (Red-Black Tree) |

---

### **Differences Between TreeMap and HashMap**

| **Aspect**               | **TreeMap**        | **HashMap**   |
| ------------------------------ | ------------------------ | ------------------- |
| **Underlying Structure** | Red-Black Tree           | Hash Table          |
| **Order**                | Sorted by keys           | Unordered           |
| **Null Support**         | Does not allow null keys | Allows one null key |
| **Performance**          | O(log n) for get/put     | O(1) for get/put    |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** What is a TreeMap, and how does it work?
   **A:** TreeMap is a key-value pair collection that maintains its keys in a **sorted order**. Internally, it uses a **Red-Black Tree**, which ensures that operations like put and get are performed in **O(log n)** time.
2. **Q:** Can a TreeMap have null keys?
   **A:** No, TreeMap does not allow null keys because it uses comparison to sort keys, and comparing `null` throws a `NullPointerException`. However, it allows multiple `null` values.

---

#### **Performance**

3. **Q:** How does TreeMap compare to HashMap in terms of performance?
   **A:**
   - TreeMap has **O(log n)** time complexity for operations like get and put due to the tree structure.
   - HashMap is faster with **O(1)** average time complexity but does not maintain order.
4. **Q:** Why is TreeMap slower than HashMap?
   **A:** TreeMap uses a Red-Black Tree, which requires balancing during insertions and deletions, resulting in **O(log n)** complexity. HashMap uses hashing, which provides **O(1)** access on average.

---

#### **Advanced**

5. **Q:** How can you create a TreeMap with custom sorting?
   **A:** Use a custom **Comparator** and pass it to the TreeMap constructor.
   Example:
   ```java
   TreeMap<Integer, String> map = new TreeMap<>((a, b) -> b - a);  // Descending order
   map.put(1, "One");
   map.put(2, "Two");
   System.out.println(map);  // Output: {2=Two, 1=One}
   ```
6. **Q:** How would you get all keys within a specific range in TreeMap?**A:** Use `subMap()` to retrieve keys within a specific range.
   Example:
   ```java
   TreeMap<Integer, String> map = new TreeMap<>();
   map.put(1, "One");
   map.put(2, "Two");
   map.put(3, "Three");
   System.out.println(map.subMap(2, 4));  // Output: {2=Two, 3=Three}
   ```
7. **Q:** Why would you use TreeMap over HashMap?
   **A:** Use TreeMap when you need keys to be sorted or require range-based operations like subsets (`headMap`, `tailMap`). HashMap is better for fast lookups without sorting requirements.

---

TreeMap is highly useful for scenarios where ordering of keys is critical, and it offers powerful methods for navigation and range queries.

---

**LinkedHashMap**, an implementation of the **Map** interface that combines the benefits of **HashMap** and **LinkedList**. It offers both fast access and maintains the order of keys and values.

---

### **LinkedHashMap Overview**

- **LinkedHashMap** is a key-value pair collection in Java that preserves the **insertion order** of keys. Like HashMap, it allows one null key and multiple null values.
- **Features:**

  1. Maintains **insertion order**.
  2. Provides fast operations like **get** and **put** with **O(1)** time complexity (average).
  3. Supports **access-order mode**, where the least recently accessed entry comes first.
  4. **Not synchronized**, meaning it’s thread-unsafe.
- **When to Use:**
  Use LinkedHashMap when you need a **Map** that preserves the insertion order or requires access-order mode for caching (e.g., **Least Recently Used (LRU)** cache).

---

### **How LinkedHashMap Works Internally**

1. LinkedHashMap extends **HashMap** and uses a doubly-linked list to maintain insertion order or access order.
2. Each node stores:
   - Key and value.
   - References (pointers) to the **previous** and **next** nodes for order tracking.
   - A bucket index (from HashMap) based on hashcode.
3. If access-order mode is enabled, the node is moved to the end of the linked list each time it is accessed.

---

### **Basic Operations**

#### **1. Adding Key-Value Pairs**

```java
import java.util.LinkedHashMap;

public class Main {
    public static void main(String[] args) {
        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();
        map.put(1, "One");
        map.put(2, "Two");
        map.put(3, "Three");
        System.out.println(map);  // Output: {1=One, 2=Two, 3=Three} (in insertion order)
    }
}
```

#### **2. Accessing Values**

```java
String value = map.get(2);  // Retrieves the value for key 2
System.out.println(value);  // Output: Two
```

#### **3. Removing Entries**

```java
map.remove(1);  // Removes the entry with key 1
System.out.println(map);  // Output: {2=Two, 3=Three}
```

#### **4. Iterating Over Entries**

```java
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

---

### **Access-Order Mode (LRU Cache Implementation)**

LinkedHashMap supports an **access-order mode** for implementing Least Recently Used (LRU) caches.

#### **Enabling Access-Order Mode**

```java
LinkedHashMap<Integer, String> lruMap = new LinkedHashMap<>(16, 0.75f, true);
lruMap.put(1, "One");
lruMap.put(2, "Two");
lruMap.get(1);  // Accessing key 1 moves it to the end
System.out.println(lruMap);  // Output: {2=Two, 1=One} (access order)
```

#### **Evicting Old Entries (Override removeEldestEntry):**

```java
LinkedHashMap<Integer, String> lruCache = new LinkedHashMap<>(16, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > 2;  // Remove oldest entry if size exceeds 2
    }
};
lruCache.put(1, "One");
lruCache.put(2, "Two");
lruCache.put(3, "Three");
System.out.println(lruCache);  // Output: {2=Two, 3=Three}
```

---

To enable **access-order mode** in `LinkedHashMap`, you do need to use the constructor with all three parameters:  **initialCapacity** ,  **loadFactor** , and  **accessOrder** . Unfortunately, there isn't a constructor in `LinkedHashMap` that allows you to simply pass `true` for enabling access-order mode without also specifying the other two parameters. Here's why:

### Constructor Signature

The `LinkedHashMap` constructor enabling access-order looks like this:

```java
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
```

### Why All Three Parameters?

* **Initial Capacity:** Sets the initial number of buckets (default is 16). Helps in tuning performance by reducing resizing operations.
* **Load Factor:** Determines how full the map can get before resizing (default is 0.75).
* **Access Order (`boolean`):** Controls whether the map is ordered by access (`true`) or insertion order (`false`).

Since Java does not provide an overloaded constructor for enabling access-order directly, all three parameters must be supplied. However, you can use the defaults for **initialCapacity** and **loadFactor** if you don't want to change them.

### Example (Using Defaults):

If you only care about enabling access-order and don't want to explicitly set the other parameters:

```java
LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);
```

### Alternative: Default Settings with Access Order

If you're building a custom utility class or wrapper, you could create your own constructor to simplify this:

```java
class AccessOrderLinkedHashMap<K, V> extends LinkedHashMap<K, V> {
    public AccessOrderLinkedHashMap() {
        super(16, 0.75f, true); // Defaults with access-order enabled
    }
}
```

This custom implementation allows you to enable access-order without repeatedly specifying parameters.

---

### **Advantages and Disadvantages**

| **Advantages**       | **Disadvantages**                   |
| -------------------------- | ----------------------------------------- |
| Maintains insertion order  | Not synchronized (thread-unsafe)          |
| Supports access-order mode | Higher memory overhead due to linked list |
| Allows null key and values | Slower than HashMap in some operations    |

---

### **Differences Between HashMap and LinkedHashMap**

| **Aspect**               | **HashMap**                 | **LinkedHashMap**                     |
| ------------------------------ | --------------------------------- | ------------------------------------------- |
| **Order**                | Unordered                         | Maintains insertion/access order            |
| **Underlying Structure** | Hash Table                        | Hash Table + Doubly-linked list             |
| **Performance**          | Faster due to simple hashing      | Slightly slower due to linked list overhead |
| **Usage**                | General-purpose key-value storage | Cache implementations or ordered storage    |

---

### **Interview-Style Questions and Answers**

#### **Basic Concepts**

1. **Q:** What is a LinkedHashMap, and how does it differ from a HashMap?
   **A:** LinkedHashMap is a key-value pair collection that maintains the insertion order, unlike HashMap, which is unordered. LinkedHashMap uses a doubly-linked list along with the hash table to track order.
2. **Q:** Can LinkedHashMap store null keys and values?
   **A:** Yes, LinkedHashMap allows one `null` key and multiple `null` values, just like HashMap.

---

#### **Performance**

3. **Q:** What is the time complexity of get and put operations in LinkedHashMap?
   **A:** The average time complexity is **O(1)**, similar to HashMap. However, maintaining the linked list for order tracking introduces slight overhead.
4. **Q:** How does LinkedHashMap handle access-order mode?
   **A:** When access-order mode is enabled, entries are moved to the end of the linked list upon access. This is useful for implementing LRU caches.

---

#### **Advanced**

5. **Q:** How would you implement an LRU cache using LinkedHashMap?
   **A:** Enable access-order mode in the constructor and override the `removeEldestEntry()` method to evict the least recently accessed entry.
   Example:
   ```java
   LinkedHashMap<Integer, String> lruCache = new LinkedHashMap<>(16, 0.75f, true) {
       @Override
       protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
           return size() > 3;  // Evict if size exceeds 3
       }
   };
   ```
6. **Q:** What happens internally when a key is accessed in access-order mode?
   **A:** The entry corresponding to the key is moved to the end of the linked list, ensuring it remains the most recently accessed entry.

---

LinkedHashMap is versatile for scenarios requiring ordered key-value mappings, especially in cache systems.

---

Here's a **comprehensive cheat sheet** for the entire **Java Collections Framework** in a tabular format. This includes interfaces, key implementations, key methods, and common use cases:

| **Interface**    | **Key Implementations**                               | **Description**                                       | **Key Methods**                                 | **Common Use Cases**                        |
| ---------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------- |
| **Collection**   | -`ArrayList`, `LinkedList`, `HashSet`, `TreeSet`    | Root interface for most collections                         | `add()`, `remove()`, `size()`, `iterator()`   | Base for all collections                          |
| **List**         | -`ArrayList`, `LinkedList`, `Vector`                  | Ordered collection (sequential access), allows duplicates   | `add(index, element)`, `get(index)`, `set()`    | Dynamic arrays, ordered data                      |
| **Set**          | -`HashSet`, `LinkedHashSet`, `TreeSet`                | Unordered collection of unique elements                     | `add()`, `remove()`, `contains()`               | Removing duplicates, fast lookups                 |
| **Queue**        | -`LinkedList`, `PriorityQueue`, `ArrayDeque`          | Follows FIFO (First-In-First-Out), offers priority queues   | `offer()`, `poll()`, `peek()`                   | Scheduling tasks, maintaining order               |
| **Deque**        | -`ArrayDeque`, `LinkedList`                             | Double-ended queue (supports both FIFO and LIFO operations) | `addFirst()`, `addLast()`, `pollFirst()`        | Implementing stacks/queues                        |
| **Map**          | -`HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable` | Key-value pairs, no duplicate keys                          | `put()`, `get()`, `remove()`, `containsKey()` | Fast key-based lookups, caching                   |
| **SortedSet**    | -`TreeSet`                                                | Set that maintains elements in sorted order                 | `first()`, `last()`, `headSet()`, `tailSet()` | Range queries, sorted unique data                 |
| **SortedMap**    | -`TreeMap`                                                | Map that maintains keys in sorted order                     | `firstKey()`, `lastKey()`, `subMap()`           | Key-value pairs in sorted order                   |
| **NavigableSet** | -`TreeSet`                                                | Extends `SortedSet` with navigation methods               | `floor()`, `ceiling()`, `higher()`, `lower()` | Advanced range queries                            |
| **NavigableMap** | -`TreeMap`                                                | Extends `SortedMap` with navigation methods               | `descendingKeySet()`, `tailMap()`, `headMap()`  | Advanced key navigation in maps                   |
| **Iterator**     | Used by all collections                                     | Provides a way to iterate through elements                  | `hasNext()`, `next()`, `remove()`               | Traversing collections                            |
| **Comparable**   | Used for custom sorting                                     | Defines natural ordering for objects                        | `compareTo()`                                       | Sorting elements using `TreeSet` or `TreeMap` |
| **Comparator**   | Used for custom sorting                                     | Provides a custom ordering logic                            | `compare()`, `equals()`                           | Custom comparison logic                           |

### Important Notes:

- **Thread-Safe Implementations:**

  - Use `Vector` or `Hashtable` for built-in thread safety (but these are largely outdated).
  - Alternatively, use `Collections.synchronizedList()` or `ConcurrentHashMap` for modern thread-safe operations.
- **Key Differences Between Implementations:**

  - **`ArrayList` vs `LinkedList`:** `ArrayList` is faster for random access, while `LinkedList` is better for frequent inserts and deletes.
  - **`HashSet` vs `TreeSet`:** `HashSet` is faster, while `TreeSet` maintains sorting order.

This table can serve as a great guide during interviews or while working on real-world Java projects.

---
